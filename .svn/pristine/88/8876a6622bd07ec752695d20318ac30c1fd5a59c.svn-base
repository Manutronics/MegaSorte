#include "dataprocessing.h"
#include <QDebug>

DataProcessing::DataProcessing(int vectCount, QWidget *parent) : QWidget(parent),
    PI2N(2 * M_PI/vectCount)
{
    inCount = checkPower2(vectCount);

    column.delta = new int[vectCount];
    column.currInterval = new int[vectCount];
    column.maxinterval = new int[vectCount];
    column.mininterval = new int[vectCount];

    if(!inCount)
        inCount = vectCount;

    xr = new float[inCount];
    xi = new float[inCount];
    wr = new float[inCount/2];
    wi = new float[inCount/2];
    ww = new float[inCount];
    rev = new int[inCount/2];

    initFFT();
}

DataProcessing::~DataProcessing()
{
    delete column.currInterval;
    delete column.delta;
    delete xr;
    delete xi;
    delete wr;
    delete wi;
    delete ww;
    delete rev;
}

// apply Hann window to input vector
void DataProcessing::windowFFT(float *s)
{
    // apply window to input signal
    for(int i = 0; i < inCount; i++)
    {
        xr[i] = ((s[i] - 128) * ww[i]);
        xi[i] = 0.0;
    } // for i
} // windowFFT


void DataProcessing::initFFT(void)
{
    int i, m, t, k;

    for(i = 0; i < inCount/2; i++)
    {
        // rotations
        wr[i] = (float)qCos(PI2N * i);
        wi[i] = (float)qSin(PI2N * i);

        // bit reversal
        t = i;
        m = 0;
        k = inCount-1;
        while(k > 0)
        {
            m = (m << 1) + (t & 1);
            t = t >> 1;
            k = k >> 1;
        }
        rev[i] = m;
    } // for i

    // initialize Hanning window vector
    for(i = 0; i < inCount; i++)
        ww[i] = 0.5 - 0.5 * qCos(PI2N * i);

} // initFFT


// Fast Fourier Transform
void DataProcessing::FFT(void)
{
    int     m, k, i, j;
    float   a, b, c, d, wwr, wwi, pr, pi;

    // FFT loop
    m = inCount/2;
    j = 0;
    while(m > 0)
    { /* log(N) cycle */
        k = 0;
        while(k < inCount)
        { // batterflies loop
            for(i = 0 ;i < m ;i++)
            { // batterfly
                a = xr[i+k];        b = xi[i+k];
                c = xr[i+k+m];      d = xi[i+k+m];
                wwr = wr[i<<j];     wwi = wi[i<<j];
                pr = a - c;         pi = b - d;

                xr[i+k]   = a + c;
                xi[i+k]   = b + d;
                xr[i+k+m] = pr * wwr - pi * wwi;
                xi[i+k+m] = pr * wwi + pi * wwr;
            } // for i
            k += m<<1 ;
        } // while k
        m >>= 1;
        j++;
    } // while m
} // FFT


void DataProcessing::powerScale(float *r)
{
    int i, j;
    float t, max;
    float xrp, xip;

    // compute signal power (in place) and find maximum
    max = 0;
    for(i = 0; i < inCount/2; i++)
    {
        j = rev[i];
        xrp = xr[j];
        xip = xi[j];
        t = (xrp*xrp) + (xip*xip);
        xr[j] = t;
        if(t < max)
            max = t;
    }
    qDebug() << "max ->" << max;

    // bit reversal, scaling of output vector as unsigned char
    max = 60.0/max;
    for(i = 0; i < inCount/2; i++)
    {
        r[i] = xr[rev[i]] * max;
    }
} // powerScale

int DataProcessing::checkPower2(int num)
{
    uint z = num;
    if(z & (z - 1))
    {
        for(z = 1; z < num; z = z<<1);
        return z;
    }
    else
    {
        return 0;
    }
}

int DataProcessing::getSize()
{
    return inCount;
}

void DataProcessing::calcNumOccurrences(QVector<int> &list, int until)
{
    int upto = until-1;
    int c, nmax, nmin, nmaxoc, nminoc;
    memset(column.occurence, 0, sizeof(int)*60);
    if(upto < 1139)
        return;
    for(int k = 1; k < 61; k++)
    {
        for(int i = 1139; i < upto; i++)
        {
            if(list[i] == k)
                column.occurence[k-1]++;
        }
    }
    for(c = 0, nmax = 0, nmin = upto; c < 60; c++)
    {
        if(column.occurence[c] < nmin)
        {
            nmin = column.occurence[c];
            nminoc = c+1;
        }
        if(column.occurence[c] > nmax)
        {
            nmax = column.occurence[c];
            nmaxoc = c+1;
        }
//        qDebug() << "max = " << nmax << "  min = " << nmin << " occurence[" << c+1 << "]=" << column.occurence[c] <<endl;
    }
    column.mostvalue = nmaxoc;
    column.mostcount = nmax;
    column.leastvalue = nminoc;
    column.leastcount = nmin;
//    qDebug() << "max = " << nmax << "  min = " << nmin << endl;
}

//void DataProcessing::calcIntervalsMean(QVector<int> &list)
//{
//    int maccum = 0, mlastcount = 0, laccum = 0, llastcount = 0;
//    int mdiv = 0, ldiv = 0;
//    int i;
//    for(i = 0; i < list.count(); i++)
//    {
//        if(list[i] == column.mostvalue)
//        {
//            qDebug() << "accum = " << maccum;
//            maccum += i - mlastcount;
//            mlastcount = i;
//            mdiv++;
//        }
//        if(list[i] == column.leastvalue)
//        {
//            laccum += i - llastcount;
//            llastcount = i;
//            ldiv++;
//        }
//    }
//    column.delta[0] = maccum/mdiv;
//    column.delta[1] = laccum/ldiv;
//    qDebug() << "deltam=" << column.delta[0] << "  maccum=" << maccum << " i=" << mdiv;
//    qDebug() << "deltal=" << column.delta[1] << "  laccum=" << laccum << " i=" << ldiv << endl;
//}

void DataProcessing::calcIntervalsMean(QVector<int> &list, int until)
{
    int upto = until;
    int accum = 0, lastcount = 0;
    int div = 0;
    int i, maxinterval = 0, mininterval = upto - 1139, delta = 10;
    if(upto < 1139)
        return;
    column.probablyValues.clear();
    for(int k = 1; k < 61; k++)
    {
        for(lastcount = i = 1139; i < upto; i++)
        {
            if(list[i] == k)
            {
                accum += i - lastcount;
                if(maxinterval < (i - lastcount))
                    maxinterval = i - lastcount;
                if(mininterval > (i - lastcount))
                    mininterval = i - lastcount;
                lastcount = i;
                div++;
            }
        }
        column.maxinterval[k-1] = maxinterval;
        column.mininterval[k-1] = mininterval;
        column.currInterval[k-1] = i - lastcount;
        column.delta[k-1] = accum/div;
        div = 0; accum = 0; maxinterval = 0; mininterval = upto - 1139;
        if(abs(column.delta[k-1] - column.currInterval[k-1]) < delta)
        {
//            delta = abs(column.currInterval[k-1] - column.delta[k-1]);
            column.probablyValues.append(k);
        }
    }
    qDebug() << "valor deve ser jogado  ";
    for (int k = 0; k < column.probablyValues.count(); k++)
        qDebug() << column.probablyValues[k] << " (" << column.occurence[column.probablyValues[k]-1] << ")"
                 << "  curr interval->" << column.currInterval[column.probablyValues[k]-1]
                 << "  max interval->" << column.maxinterval[column.probablyValues[k]-1]
                 << "  min interval->" << column.mininterval[column.probablyValues[k]-1]
                 << "  mean intervals->" << column.delta[column.probablyValues[k]-1]
                 << "  diff->" << column.delta[column.probablyValues[k]-1]-column.currInterval[column.probablyValues[k]-1];

    qDebug() << "  mais siu->" << column.mostvalue << "  menos saiu->" << column.leastvalue;
}

void DataProcessing::showIntervalsOf(int num, QVector<int> &value)
{
    qDebug() << " value->" << " (" << column.occurence[value[num-1]-1] << ")"
            << value[num-1] << " currinterval->" << column.currInterval[value[num-1]-1] << "  diff->" << column.delta[value[num-1]-1]-column.currInterval[value[num-1]-1]
            << " max inerval->" << column.maxinterval[value[num-1]-1] << " min interval->" << column.mininterval[value[num-1]-1];
}

int DataProcessing::genPass(QVector<int> &list)
{
    uint passLen = 1;
    int ret, two = 2;//rand();
    Q_ASSERT(passLen > 0);

    ////////////////////
    //Charset
    ////////////////////
    QString m_charset("0123456789");

    if(list.count() > 9)
        passLen = 2;

    start:
    //////////
    // Rand()
    //////////
    if(two&1)
    {
        QString password("");

        for(uint i = 0; i < passLen; ++i)
        {
            password[i] = m_charset[rand()%m_charset.size()];
        }
        ret = password.toInt();

    }
    ////////////
    // Mersenne
    ////////////
    else
    {
        std::uniform_int_distribution<> dist(0, m_charset.size()-1);
        QString rChars;
        rChars.resize(passLen);
        for(uint i = 0; i < passLen; ++i)
        {
            rChars[i] = m_charset[dist(m_rngEngine)];
        }
       ret = rChars.toInt();
    }
    if(ret < list.count())
        ret = list.at(ret);
    else
        goto start;

    return ret;
}

void DataProcessing::findQuadrants(QVector<int> &list)
{
    for(int k = 1139; k < list.count(); k++)
    {
        int l = list.at(k);
        for(int i = 1, score = 0; i < 26; i++)
        {
            if(l == i)
            {
                column.quadrant.append(1);
                break;
            }
            else if(l == (i+30))
            {
                column.quadrant.append(4);
                break;
            }
            if(i-score == 5){i += 5; score+=10;}
        }
        for(int i = 6, score = 0; i < 31; i++)
        {
            if(l == i)
            {
                column.quadrant.append(2);
                break;
            }
            else if(l == (i+30))
            {
                column.quadrant.append(3);
                break;
            }
            if(i-score == 10){i += 5; score+=10;}
        }
    }
}

void DataProcessing::nextQuadrantEstatistical(int qdrnt)
{
    for(int i = 0; i < column.quadrant.count()-1; i++)
    {
        if(column.quadrant.at(i)==qdrnt)
        {
            column.nextquadrant.append(column.quadrant.at(i+1));
        }
    }
}

void convolve (double *p_coeffs, int p_coeffs_n,
               double *p_in, double *p_out, int n)
{
  int i, j, k;
  double tmp;

  for (k = 0; k < n; k++)  //  position in output
  {
    tmp = 0;

    for (i = 0; i < p_coeffs_n; i++)  //  position in coefficients array
    {
      j = k - i;  //  position in input

      if (j >= 0)  //  bounds check for input buffer
      {
        tmp += p_coeffs [k] * p_in [j];
      }
    }

    p_out [i] = tmp;
  }
}

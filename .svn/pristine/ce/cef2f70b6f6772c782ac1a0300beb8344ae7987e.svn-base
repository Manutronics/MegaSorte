#include "colorslider.h"
#include "ui_colorslider.h"
#include "layoutoverlay.h"
#include <QMessageBox>
#include <QtMath>
#include <QFile>

ColorSlider::ColorSlider(QWidget *parent) :
    QWidget(parent),
    ui(new Ui::ColorSlider)
{
    ui->setupUi(this);


//        setStyleSheet("background:transparent;");
//        setAttribute(Qt::WA_TranslucentBackground);
//        setWindowFlags(Qt::FramelessWindowHint);

    ui->horizontalSlider->setRange(0, 511);//color slider
    ui->label->setAutoFillBackground(true);

    // create connection between axes and scroll bars:
    connect(ui->horizontalScrollBar, SIGNAL(valueChanged(int)), this, SLOT(horzScrollBarChanged(int)));
    connect(ui->plot->xAxis, SIGNAL(rangeChanged(QCPRange)), this, SLOT(xAxisChanged(QCPRange)));
    connect(ui->plot->yAxis, SIGNAL(rangeChanged(QCPRange)), this, SLOT(yAxisChanged(QCPRange)));

    // initialize axis range (and scroll bar positions via signals we just connected):
//    ui->plot->xAxis->setRange(0, 100, Qt::AlignLeft);
//    ui->plot->xAxis->setTickStep(1);
//    ui->plot->xAxis->setAutoTickCount(1);
//    ui->plot->yAxis->setRange(1, 5, Qt::AlignBottom);
//    ui->plot->yAxis->setTickStep(1);
//    ui->plot->yAxis->setAutoTickCount(1);
//    ui->plot->setInteractions(QCP::iRangeZoom);
    ui->plot->xAxis->axisRect()->setRangeDrag(Qt::Horizontal);
    ui->plot->xAxis->axisRect()->setRangeZoom(Qt::Horizontal);
//    ui->plot2->setVisible(false);
//    ui->plot3->setVisible(false);
//    ui->plot4->setVisible(false);
//    ui->plot5->setVisible(false);
//    ui->plot6->setVisible(false);

//    ui->plot->yAxis->setOffset(3);
    if(!funcao("d_mega.htm"))
        return;

    createGridNumbers(&labelNumbs1, ui->tab_2);
//    createGridNumbers(&labelNumbs2, ui->tab_4);
    ui->horizontalScrollBar->setMaximum((columnsNumbers[FIRSTCOL].count()-1140)*1000);
    ui->horizontalScrollBar->setRange(0, (columnsNumbers[FIRSTCOL].count()-1140)*1000);
    ui->horizontalScrollBar->setSingleStep(5);

//    ui->tab_2->setLayout(gbl);
    ui->tableWidget->verticalHeader()->setVisible(false);
    ui->tableWidget->horizontalHeader()->setVisible(false);
    ui->tableWidget->horizontalHeader()->setSectionResizeMode(QHeaderView::Stretch);
    ui->tableWidget->horizontalHeader()->setSectionResizeMode(1, QHeaderView::ResizeToContents);
    for(int i = 8; i < 20; i++)
        ui->tableWidget->hideColumn(i);
    ui->tableWidget->setSelectionBehavior(QAbstractItemView::SelectRows);
    ui->tableWidget->scrollToBottom();
    ui->tableWidget->setAlternatingRowColors(true);

    ui->tableRegister->verticalHeader()->setVisible(false);
    ui->tableRegister->horizontalHeader()->setVisible(false);
    ui->tableRegister->horizontalHeader()->setSectionResizeMode(QHeaderView::Stretch);
    ui->tableRegister->horizontalHeader()->setSectionResizeMode(0, QHeaderView::ResizeToContents);
    ui->tableRegister->setAlternatingRowColors(true);


    ui->spnFrom->setEnabled(false);
    ui->spnTo->setMaximum(columnsNumbers[FIRSTCOL].count());
    ui->spnTo->setValue(columnsNumbers[FIRSTCOL].count());
    ui->lblTurn->setText(QString::number(columnsNumbers[FIRSTCOL].count()));

    for(int i = FIRSTCOL; i < NUMCOLUMNS; i++)
        proc[i] = new DataProcessing(columnsNumbers[i].count(), this);
//    proc2 = new DataProcessing(secondcol.count(), this);
//    proc3 = new DataProcessing(thirdcol.count(), this);
//    proc4 = new DataProcessing(fourthcol.count(), this);
//    proc5 = new DataProcessing(fifethcol.count(), this);
//    proc6 = new DataProcessing(sixthcol.count(), this);

}

ColorSlider::~ColorSlider()
{
    if(proc)
        for(int i = FIRSTCOL; i < NUMCOLUMNS; i++)
            delete proc[i];
//    delete proc2;
//    delete proc3;
//    delete proc4;
//    delete proc5;
//    delete proc6;
    delete ui;
}

bool ColorSlider::funcao(QString filename)
{
    QVector<int> emptylines;
    QFile file(filename);
    QStringList lines;
    QString line;

    if(!file.open(QIODevice::ReadOnly))
    {
        QMessageBox::information(0, "error", file.errorString());
        return false;
    }

    QTextStream in(&file);
    int i = 0;

    while(!in.atEnd())
    {
        line += in.readLine();
        if(line.contains("</tr>"))
        {
            lines = line.split(QRegularExpression("\<tr.*?\>|\<\/tr\>"), QString::SkipEmptyParts);
            ui->tableWidget->setRowCount(ui->tableWidget->rowCount() + 1);
            foreach(QString sort, lines)
            {

                QStringList fields = sort.split(QRegularExpression("\<td.*?\>|\<\/td\>|&nbsp|\\s+\ts+\ts+"), QString::SkipEmptyParts);
                int j = 0;

                foreach(QString str, fields)
                {
                    if(str.contains("\r"))
                        continue;
                    QTableWidgetItem *lengthItem = new QTableWidgetItem(str);
                    ui->tableWidget->setItem(i, j, lengthItem);
                    if(j==2)
                        columnsNumbers[FIRSTCOL].append(str.toInt());
                    if(j==3)
                        columnsNumbers[SECONDCOL].append(str.toInt());
                    if(j==4)
                        columnsNumbers[THIRDCOL].append(str.toInt());
                    if(j==5)
                        columnsNumbers[FOURTHCOL].append(str.toInt());
                    if(j==6)
                        columnsNumbers[FIFTHCOL].append(str.toInt());
                    if(j==7)
                        columnsNumbers[SIXTHCOL].append(str.toInt());
                    if((j>1)&&(j<8))
                        ui->tableWidget->item(i, j)->setData(Qt::TextAlignmentRole, Qt::AlignCenter);
                    j++;
                }
            }
            QTableWidgetItem *item1 = ui->tableWidget->item(i,0);
            if(item1)
            {
                if(item1->text().toInt()==0)
                {
                    QTableWidgetItem *item2 = ui->tableWidget->item(i-1,0);
                    if(item2->text().toInt()!=0)
                    {
                        emptylines.append(i);
                    }
                    else
                    {
                        emptylines.append(emptylines.last()+1);
                    }
//                    qDebug()<< "item1=" << i << "   text->" << item1->text() << "  diff=" << i - item2->text().toInt();
                }

            }
            else
            {
                i--;
            }
            i++;
            line.clear();
            lines.clear();

        }
    }
    file.close();
//    qDebug() << emptylines << "  size" << emptylines.size() << "   length" << emptylines.length() << endl;
    for(int k = emptylines.length()-1; k >= 0; k--)
    {
        ui->tableWidget->removeRow(emptylines[k]);
    }
    ui->tableWidget->setRowCount(i-emptylines.length());
    qDebug() << columnsNumbers[FIRSTCOL].size();
    return true;
}

void ColorSlider::on_horizontalSlider_sliderMoved(int position)
{
    QPalette palette;
    QColor color;
    int r, g, b;
    r = 255;
    g = (255 - (511 - position))>0?qFloor(256 - (255 - (511 - position))):255;
    b = (255 - (511 - position))<0?qFloor(511 - (position * 2)/2):0;
    color.setRgb(qRgb(r, g, b));
    palette.setColor(ui->label->backgroundRole(), color);
    ui->label->setPalette(palette);
}

void ColorSlider::setupPlot(QVector<int> &parx)
{
//    int i, j;
    // The following plot setup is mostly taken from the plot demos:
    ui->plot->clearGraphs();
    ui->plot->addGraph();

    ui->plot->graph()->setPen(QPen(Qt::blue));
    ui->plot->graph()->setLineStyle(QCPGraph::lsLine);
    ui->plot->graph()->setScatterStyle(QCPScatterStyle(QCPScatterStyle::ssCircle, Qt::red, Qt::yellow, 5));
//    ui->plot->graph()->setBrush(QBrush(QColor(0, 0, 255, 0)));
    QVector<double> x(parx.size()), y(parx.size()), y2(parx.size());
//    float inB[proc1->getSize()], xfft[proc1->getSize()];
//    // test sinusoid
//    for ( i = j = firstcol.count()-proc1->getSize(); i < firstcol.count(); i++)
//    {

//        inB[i - j] = (float)firstcol[i];
//        xfft[i - j] = (float)i-proc1->getSize();
//    } // for

//    proc1->windowFFT(inB);
//    proc1->FFT();
//    proc1->powerScale(inB);

    for (int i = 0; i < parx.size(); i++)
    {
        x.append(parx.at(i));
        y.append(i);
    }

    ui->plot->graph(0)->setData(y, x);
    ui->plot->axisRect()->setupFullAxesBox();
    ui->plot->setInteractions(QCP::iRangeDrag | QCP::iRangeZoom);
    ui->plot->yAxis->setRange(0, 5);
//    ui->plot->yAxis->rescale(true);
    ui->plot->yAxis->setTickStep(1);
    ui->plot->yAxis->setAutoTickCount(1);
    ui->plot->replot();
}

void ColorSlider::setupPlot()
{
    int sz = proc[FIRSTCOL]->column.quadrant.size();
    // The following plot setup is mostly taken from the plot demos:
    ui->plot->clearGraphs();
    QVector<double> x(sz), y(sz);
    for(int k = FIRSTCOL; k < NUMCOLUMNS; k++)
    {
        ui->plot->addGraph();
        ui->plot->graph()->setPen(QPen(Qt::blue));
        ui->plot->graph()->setLineStyle(QCPGraph::lsLine);
        ui->plot->graph()->setScatterStyle(QCPScatterStyle(QCPScatterStyle::ssCircle, Qt::red, Qt::yellow, 5));
        for (int i = 0; i < sz; i++)
        {
            x.append(i);
            y.append(proc[k]->column.quadrant.at(i)+(k*5));
        }
        ui->plot->graph()->setData(x, y);
        x.clear();
        y.clear();
    }
    ui->plot->axisRect()->setupFullAxesBox();
    ui->plot->setInteractions(QCP::iRangeDrag | QCP::iRangeZoom);
    ui->plot->yAxis2->setVisible(true);
    ui->plot->yAxis->setRange(0, 30);
    ui->plot->yAxis2->setRange(0, 5);
//    ui->plot->yAxis->rescale(true);
    QVector<double> yTicks, y2Ticks;
    QVector<QString> yLabels, y2Labels;
    yLabels << " " << "1" << "2" << "3" << "4" << " " << "1" << "2" << "3" << "4" << " " << "1" << "2" << "3" << "4"
            << " " << "1" << "2" << "3" << "4" << " " << "1" << "2" << "3" << "4" << " " << "1" << "2" << "3" << "4" << " ";
//    y2Labels << QString::fromLatin1("Coluna") << QString::fromLatin1("Coluna") << QString::fromLatin1("Coluna")
//                << QString::fromLatin1("Coluna")<< QString::fromLatin1("Coluna") << QString::fromLatin1("Coluna");
    y2Labels << "Coluna" << "Coluna" << "Coluna"
                << "Coluna" << "Coluna" << "Coluna";
    yTicks << 0 << 1 << 2 << 3 << 4 << 5 << 6 << 7 << 8 << 9 << 10 << 11 << 12 << 13 << 14 << 15
           << 16 << 17 << 18 << 19 << 20 << 21 << 22 << 23 << 24 << 25 << 26 << 27 << 28 << 29 << 30;
    y2Ticks << 0 << 1 << 2 << 3 << 4 << 5;// << 6;
    ui->plot->yAxis2->setAutoTicks(false);
    ui->plot->yAxis2->setAutoTickLabels(false);
    ui->plot->yAxis2->setTickVector(y2Ticks);
    ui->plot->yAxis2->setTickVectorLabels(y2Labels);
    ui->plot->yAxis->setAutoTicks(false);
    ui->plot->yAxis->setAutoTickLabels(false);
    ui->plot->yAxis->setTickVector(yTicks);
    ui->plot->yAxis->setTickVectorLabels(yLabels);
    ui->plot->replot();
}

void ColorSlider::horzScrollBarChanged(int value)
{
//    if (qAbs(ui->plot->xAxis->range().center()-value/100.0) > 0.01) // if user is dragging plot, we don't want to replot twice
//    {
//        ui->plot->xAxis->setRange(value/100, ui->plot->xAxis->range().size(), Qt::AlignCenter);
//        ui->plot->replot();
//    }
}

void ColorSlider::vertScrollBarChanged(int value)
{
//    if (qAbs(ui->plot->yAxis->range().center()+value/100.0) > 0.01) // if user is dragging plot, we don't want to replot twice
//    {
//        ui->plot->yAxis->setRange(-value/100.0, ui->plot->yAxis->range().size(), Qt::AlignCenter);
//        ui->plot->replot();
//    }
}

void ColorSlider::xAxisChanged(QCPRange range)
{
//    ui->horizontalScrollBar->setValue(qRound(range.center()*100.0)); // adjust position of scroll bar slider
//    ui->horizontalScrollBar->setPageStep(qRound(range.size()*100.0)); // adjust size of scroll bar slider
}

void ColorSlider::yAxisChanged(QCPRange range)
{
//    ui->verticalScrollBar->setValue(qRound(-range.center()*100.0)); // adjust position of scroll bar slider
//    ui->verticalScrollBar->setPageStep(qRound(range.size()*100.0)); // adjust size of scroll bar slider
}


void ColorSlider::on_btnSelect_clicked()
{
//    int sorteio = 1700;
//    int coluna = 2;
//    QTableWidgetItem *item1 = ui->tableWidget->item(sorteio-1, coluna++);

//    setupPlot(firstcol);
    int column = ui->spnColumn->value()-1;
    colorizeSequence(columnsNumbers[column], ui->spnTo->value()-10, ui->spnTo->value(), column);
    QColor color;
    if(column == 0)
    {
        color.setRgbF(1, 0, 0, 0.5);
    }
    else if (column == 1)
    {
        color.setRgbF(0, 1, 0, 0.5);
    }
    else if (column == 2)
    {
        color.setRgbF(0, 0, 1, 0.5);
    }
    else if (column == 3)
    {
        color.setRgbF(0, 1, 1, 0.5);
    }
    else if (column == 4)
    {
        color.setRgbF(1, 1, 0, 0.5);
    }
    else if (column == 5)
    {
        color.setRgbF(1, 0, 1, 0.5);
    }

    LoadingOverlay *lo = new LoadingOverlay(ui->tab_2, &line, &color);
    lo->setObjectName("mypath");
    emit ui->tab_2->resize(this->size());
    int upto = ui->spnTo->value();
    for(int i = FIRSTCOL; i < NUMCOLUMNS; i++)
    {
        proc[i]->calcNumOccurrences(columnsNumbers[i], upto);
        proc[i]->calcIntervalsMean(columnsNumbers[i], upto, ui->chkIsMean->isChecked());
    }
//    proc2->calcNumOccurrences(secondcol, upto);
//    proc2->calcIntervalsMean(secondcol, upto);
//    proc3->calcNumOccurrences(thirdcol, upto);
//    proc3->calcIntervalsMean(thirdcol, upto);
//    proc4->calcNumOccurrences(fourthcol, upto);
//    proc4->calcIntervalsMean(fourthcol, upto);
//    proc5->calcNumOccurrences(fifethcol, upto);
//    proc5->calcIntervalsMean(fifethcol, upto);
//    proc6->calcNumOccurrences(sixthcol, upto);
//    proc6->calcIntervalsMean(sixthcol, upto);
//    ui->btnSelect->setText(QString("%1 %2").arg(proc1->column.mostvalue).arg(proc1->column.leastvalue));
//    QWidget *nova = new QWidget(ui->tableWidget);
//    ui->tabObject->addTab(nova, "nova");
//    createGridNumbers(&labelNumbs3, nova);
//    for(int k = 0; k < 60; k++)
//    {
//        qDebug() << QString("ocorrencia de %1").arg(k+1, 2, 10,QChar('0'))
//                << QString(" foi %1").arg(proc[FIRSTCOL]->column.occurence[k], 2, 10, QChar('0'))
//                << QString(" foi %1").arg(proc[SECONDCOL]->column.occurence[k], 2, 10, QChar('0'))
//                << QString(" foi %1").arg(proc[THIRDCOL]->column.occurence[k], 2, 10, QChar('0'))
//                << QString(" foi %1").arg(proc[FOURTHCOL]->column.occurence[k], 2, 10, QChar('0'))
//                << QString(" foi %1").arg(proc[FIFTHCOL]->column.occurence[k], 2, 10, QChar('0'))
//                << QString(" foi %1").arg(proc[SIXTHCOL]->column.occurence[k], 2, 10, QChar('0'));
//    }
}

void ColorSlider::colorizeSequence(QVector<int> vect, int start, int finish, int column)
{
    QString border;
    switch(column)
    {
    case FIRSTCOL:
        border = "border: 2px solid red;";
        break;
    case SECONDCOL:
        border = "border: 2px solid lime;";
        break;
    case THIRDCOL:
        border = "border: 2px solid blue;";
        break;
    case FOURTHCOL:
        border = "border: 2px solid cyan;";
        break;
    case FIFTHCOL:
        border = "border: 2px solid yellow;";
        break;
    case SIXTHCOL:
        border = "border: 2px solid magenta;";
        break;
    default:
        return;
    }

    double percentage = (511 - (finish-start&0x1FF))/511.0;

    for(int i = start, cr = 4095; i < finish; i++, cr -=(4095/(finish-start)))
    {
        QString complement = QString("background: #%1%2%3").arg(cr, 3, 16,QChar('0')).arg(cr, 3, 16,QChar('0')).arg(cr, 3, 16,QChar('0'));
        labelNumbs1[vect[i]-1]->setStyleSheet(border+complement);
        if(i==start)
        {
            QPoint p = labelNumbs1[vect[i]-1]->pos();
            int woff = labelNumbs1[vect[i]-1]->width()/2;
            int hoff = labelNumbs1[vect[i]-1]->height()/2;
            p.setX(p.x()+woff);
            p.setY(p.y()+hoff);
            line.moveTo(p);
        }
        else
        {
            QPoint p = labelNumbs1[vect[i]-1]->pos();
            int woff = labelNumbs1[vect[i]-1]->width()/2;
            int hoff = labelNumbs1[vect[i]-1]->height()/2;
            p.setX(p.x()+woff);
            p.setY(p.y()+hoff);
            line.lineTo(p);
        }
    }
    update();
}

void ColorSlider::wheelEvent(QWheelEvent * event)
{
    bool visible = false;
    QList<QLabel*> *labelNum;
    int *theindex;
    static int index2= columnsNumbers[FIRSTCOL].size()-1, index4 = columnsNumbers[FIRSTCOL].size()-1;

    if(ui->tab_2->isVisible())
    {
        theindex = &index2;
        visible = true;
        labelNum = &labelNumbs1;
    }
//    else if(ui->tab_4->isVisible())
//    {
//        theindex = &index4;
//        visible = true;
//        labelNum = &labelNumbs2;
//    }
    if(visible)
    {
        QColor color;
        QPalette palette;
        color.setBlue(0xFF);
        color.setGreen(0xFF);
        color.setRed(0xFF);

        if(!ui->chkIsDrawable->isChecked()||!(ui->chkRedBall->isChecked()||ui->chkGreenBall->isChecked()||ui->chkBlueBall->isChecked()||
                                             ui->chkCyanBall->isChecked()||ui->chkMagentaBall->isChecked()||ui->chkYellowBall->isChecked()))
        {
            for(int i = FIRSTCOL; i < NUMCOLUMNS; i++)
            {
                palette.setColor((*labelNum)[columnsNumbers[i][(*theindex)]-1]->backgroundRole(), color);
                (*labelNum)[columnsNumbers[i][(*theindex)]-1]->setPalette(palette);
            }
        }
//        palette.setColor((*labelNum)[secondcol[(*theindex)]-1]->backgroundRole(), color);
//        (*labelNum)[secondcol[(*theindex)]-1]->setPalette(palette);
//        palette.setColor((*labelNum)[thirdcol[(*theindex)]-1]->backgroundRole(), color);
//        (*labelNum)[thirdcol[(*theindex)]-1]->setPalette(palette);
//        palette.setColor((*labelNum)[fourthcol[(*theindex)]-1]->backgroundRole(), color);
//        (*labelNum)[fourthcol[(*theindex)]-1]->setPalette(palette);
//        palette.setColor((*labelNum)[fifethcol[(*theindex)]-1]->backgroundRole(), color);
//        (*labelNum)[fifethcol[(*theindex)]-1]->setPalette(palette);
//        palette.setColor((*labelNum)[sixthcol[(*theindex)]-1]->backgroundRole(), color);
//        (*labelNum)[sixthcol[(*theindex)]-1]->setPalette(palette);

        if(event->angleDelta().ry()>0)
        {
            (*theindex)++;
            if((*theindex)>(columnsNumbers[FIRSTCOL].count()-1))
                (*theindex) = columnsNumbers[FIRSTCOL].count()-1;

//            qDebug()<< "ifirstcol[(*theindex)]" << firstcol[(*theindex)] << (*theindex);
        }
        else
        {
            (*theindex)--;
            if((*theindex) < 0)
                (*theindex) = 0;
//            qDebug()<< "efirstcol[(*theindex)]" << firstcol[(*theindex)] << (*theindex);
        }
        if(ui->chkRedBall->isChecked())
        {
            color.setBlue(0x00);
            color.setGreen(0x00);
            color.setRed(0xFF);
            palette.setColor((*labelNum)[columnsNumbers[FIRSTCOL][(*theindex)]-1]->backgroundRole(), color);
            (*labelNum)[columnsNumbers[FIRSTCOL][(*theindex)]-1]->setPalette(palette);
        }
        if(ui->chkGreenBall->isChecked())
        {
            color.setBlue(0x00);
            color.setGreen(0xFF);
            color.setRed(0x00);
            palette.setColor((*labelNum)[columnsNumbers[SECONDCOL][(*theindex)]-1]->backgroundRole(), color);
            (*labelNum)[columnsNumbers[SECONDCOL][(*theindex)]-1]->setPalette(palette);
        }
        if(ui->chkBlueBall->isChecked())
        {
            color.setBlue(0xFF);
            color.setGreen(0x00);
            color.setRed(0x00);
            palette.setColor((*labelNum)[columnsNumbers[THIRDCOL][(*theindex)]-1]->backgroundRole(), color);
            (*labelNum)[columnsNumbers[THIRDCOL][(*theindex)]-1]->setPalette(palette);
        }
        if(ui->chkCyanBall->isChecked())
        {
            color.setBlue(0xFF);
            color.setGreen(0xFF);
            color.setRed(0x00);
            palette.setColor((*labelNum)[columnsNumbers[FOURTHCOL][(*theindex)]-1]->backgroundRole(), color);
            (*labelNum)[columnsNumbers[FOURTHCOL][(*theindex)]-1]->setPalette(palette);
        }
        if(ui->chkMagentaBall->isChecked())
        {
            color.setBlue(0xFF);
            color.setGreen(0x00);
            color.setRed(0xFF);
            palette.setColor((*labelNum)[columnsNumbers[FIFTHCOL][(*theindex)]-1]->backgroundRole(), color);
            (*labelNum)[columnsNumbers[FIFTHCOL][(*theindex)]-1]->setPalette(palette);
        }
        if(ui->chkYellowBall->isChecked())
        {
            color.setBlue(0x00);
            color.setGreen(0xFF);
            color.setRed(0xFF);
            palette.setColor((*labelNum)[columnsNumbers[SIXTHCOL][(*theindex)]-1]->backgroundRole(), color);
            (*labelNum)[columnsNumbers[SIXTHCOL][(*theindex)]-1]->setPalette(palette);
        }
        ui->lblTurn->setText(QString::number((*theindex)+1));
    }
}

void ColorSlider::createGridNumbers(QList<QLabel *> *numbs, QWidget *tab)
{
    QPalette palette;
    QColor color;
    QGridLayout *gbl = new QGridLayout(this);
    for(int i = 1, p = 0; i < 7; i++)
    {
        for(int j = 1; j < 11;j++, p++)
        {
            QLabel *lblnum = new QLabel(QString("%1").arg(p+1, 2, 10,QChar('0')));
            (*numbs) << lblnum;
            gbl->addWidget(lblnum, i, j);
            (*numbs)[p]->setAutoFillBackground(true);
            color.setBlue(0xFF);
            color.setGreen(0xFF);
            color.setRed(0xFF);
            palette.setColor((*numbs)[p]->backgroundRole(), color);
            (*numbs)[p]->setPalette(palette);
            (*numbs)[p]->setAlignment(Qt::AlignCenter);
        }
    }
    gbl->setSpacing(23);
    color.setBlue(0xFF);
    color.setGreen(0x55);
    color.setRed(0xFF);
    for(int i = FIRSTCOL; i < NUMCOLUMNS; i++)
    {
        palette.setColor((*numbs)[columnsNumbers[i].last()-1]->backgroundRole(), color);
        (*numbs)[columnsNumbers[i].last()-1]->setPalette(palette);
    }
//    palette.setColor((*numbs)[secondcol.last()-1]->backgroundRole(), color);
//    (*numbs)[secondcol.last()-1]->setPalette(palette);
//    palette.setColor((*numbs)[thirdcol.last()-1]->backgroundRole(), color);
//    (*numbs)[thirdcol.last()-1]->setPalette(palette);
//    palette.setColor((*numbs)[fourthcol.last()-1]->backgroundRole(), color);
//    (*numbs)[fourthcol.last()-1]->setPalette(palette);
//    palette.setColor((*numbs)[fifethcol.last()-1]->backgroundRole(), color);
//    (*numbs)[fifethcol.last()-1]->setPalette(palette);
//    palette.setColor((*numbs)[sixthcol.last()-1]->backgroundRole(), color);
//    (*numbs)[sixthcol.last()-1]->setPalette(palette);
    tab->setLayout(gbl);
    tab->setMaximumHeight(320);
    tab->setMinimumHeight(120);
    tab->setMaximumWidth(640);
    tab->setMinimumWidth(240);
}

void ColorSlider::paintEvent(QPaintEvent *event)
{
//    LoadingOverlay *lo = ui->tab_2->findChild<LoadingOverlay *>("mypath");
//    if(lo != NULL)
//    {
//        delete lo;
//        colorizeSequence(firstcol, 1700, 1711, 6);
//        LoadingOverlay *ll = new LoadingOverlay(ui->tab_2, &line);
//        ll->setObjectName("mypath");
//        emit ui->tab_2->resize(this->size());
//    }
}

void ColorSlider::on_pushButton_clicked()
{
    qDebug() << proc[FIRSTCOL]->genPass(proc[FIRSTCOL]->column.probablyValues, ui->spnQuadrant1->value());
    qDebug() << proc[SECONDCOL]->genPass(proc[SECONDCOL]->column.probablyValues, ui->spnQuadrant2->value());
    qDebug() << proc[THIRDCOL]->genPass(proc[THIRDCOL]->column.probablyValues, ui->spnQuadrant3->value());
    qDebug() << proc[FOURTHCOL]->genPass(proc[FOURTHCOL]->column.probablyValues, ui->spnQuadrant4->value());
    qDebug() << proc[FIFTHCOL]->genPass(proc[FIFTHCOL]->column.probablyValues, ui->spnQuadrant5->value());
    qDebug() << proc[SIXTHCOL]->genPass(proc[SIXTHCOL]->column.probablyValues, ui->spnQuadrant6->value());

//    proc[ui->spnColumn->value()]->showIntervalsOf(ui->spnColumn->value(), proc[SIXTHCOL]->column.probablyValues);
//    if(ui->spnColumn->value()==1)
//    {
//        proc[ui->spnColumn->value()-1]->findQuadrants(columnsNumbers[ui->spnColumn->value()-1]);
//        proc1->nextQuadrantEstatistical(proc1->column.quadrant.last());
//        setupPlot(proc[ui->spnColumn->value()-1]->column.quadrant);
//    }
//    else if(ui->spnColumn->value()==2)
//    {
//        proc[SECONDCOL]->findQuadrants(columnsNumbers[SECONDCOL]);
//        setupPlot(proc[SECONDCOL]->column.quadrant);
//    }
//    else if(ui->spnColumn->value()==3)
//    {
//        proc[THIRDCOL]->findQuadrants(columnsNumbers[THIRDCOL]);
//        setupPlot(proc[THIRDCOL]->column.quadrant);
//    }
//    else if(ui->spnColumn->value()==4)
//    {
//        proc[FOURTHCOL]->findQuadrants(columnsNumbers[FOURTHCOL]);
//        setupPlot(proc[FOURTHCOL]->column.quadrant);
//    }
//    else if(ui->spnColumn->value()==5)
//    {
//        proc[FIFTHCOL]->findQuadrants(columnsNumbers[FIFTHCOL]);
//        setupPlot(proc[FIFTHCOL]->column.quadrant);
//    }
//    else if(ui->spnColumn->value()==6)
//    {
//        proc[SIXTHCOL]->findQuadrants(columnsNumbers[SIXTHCOL]);
//        setupPlot(proc[SIXTHCOL]->column.quadrant);
//    }
}

void ColorSlider::on_btnCalculate_clicked()
{
    for(int i = FIRSTCOL; i < NUMCOLUMNS; i++)
    {
        proc[i]->allprocess = false;
        proc[i]->findQuadrants(columnsNumbers[i]);
        proc[i]->showIntervalsOf(ui->spnTo->value(), columnsNumbers[i]);
    }

    setupPlot();
}

void ColorSlider::on_btn_automate_clicked()
{
    QVector<int> gain;
    int rules = 0, matchfound = 0;
    //start the counter here
    for(int f = 1150; f < columnsNumbers[FIRSTCOL].count()-1; f++)
    {
        ui->spnTo->setValue(f); //first round with new rules

    //    generate the statistical here
        int upto = ui->spnTo->value();
        for(int h = FIRSTCOL; h < NUMCOLUMNS; h++)
        {
            proc[h]->allprocess = true;
            proc[h]->calcNumOccurrences(columnsNumbers[h], upto);
            proc[h]->calcIntervalsMean(columnsNumbers[h], upto, ui->chkIsMean->isChecked());
        }

        ui->spnTo->setValue(f+1);

        for(int i = FIRSTCOL; i < NUMCOLUMNS; i++)
        {
            proc[i]->findQuadrants(columnsNumbers[i]);
//            proc[i]->showIntervalsOf(ui->spnTo->value(), columnsNumbers[i]);
        }

        //process the numbers of the next level here
        for(int i = FIRSTCOL; i < NUMCOLUMNS; i++)
        {            
            for(int k = 0; k < proc[i]->column.probablyValues.count(); k++)
            {
//                qDebug() << "column" << i+1;
                if(proc[i]->column.probablyValues.at(k) ==  columnsNumbers[i].at(f))
                {
                    rules++;
//                    qDebug() << "oi" << proc[i]->column.probablyValues.at(k) <<  columnsNumbers[i].at(f) << "rules" << rules;
                    break;
                }
            }
            if(rules == 6)
            {
                if(i == 5)
                {
                    matchfound++;
                    gain << f+1;
                }
                rules = 0;
                break;
            }
        }
    }
    qDebug() << "resultado esperado-> " << matchfound << "  nos sorteios-> " << gain;
    //generate the next numbers compare with the real numbers
}

void ColorSlider::on_btnClearPanel_clicked()
{
    for(int k = 0; k < 59; k++)
        labelNumbs1[k]->setStyleSheet("");
}

void ColorSlider::on_btnSimulate_clicked()
{
    QVector<int> gain;
    int rules = 0, matchfound = 0;
    //start the counter here
    for(int f = 1150; f < columnsNumbers[FIRSTCOL].count()-1; f++)
    {
        ui->spnTo->setValue(f); //first round with new rules

    //    generate the statistical here
        int upto = ui->spnTo->value();
        for(int h = FIRSTCOL; h < NUMCOLUMNS; h++)
        {
            proc[h]->allprocess = true;
            proc[h]->calcNumOccurrences(columnsNumbers[h], upto);
            proc[h]->calcIntervalsMean(columnsNumbers[h], upto, ui->chkIsMean->isChecked());
        }

        ui->spnTo->setValue(f+1);

//        for(int i = FIRSTCOL; i < NUMCOLUMNS; i++)
//        {
//            proc[i]->findQuadrants(columnsNumbers[i]);
//            proc[i]->showIntervalsOf(ui->spnTo->value(), columnsNumbers[i]);
//        }

        //process the numbers of the next level here
        int c1 = proc[FIRSTCOL]->genPass(proc[FIRSTCOL]->column.probablyValues, ui->spnQuadrant1->value());
        int c2 = proc[SECONDCOL]->genPass(proc[SECONDCOL]->column.probablyValues, ui->spnQuadrant2->value());
        int c3 = proc[THIRDCOL]->genPass(proc[THIRDCOL]->column.probablyValues, ui->spnQuadrant3->value());
        int c4 = proc[FOURTHCOL]->genPass(proc[FOURTHCOL]->column.probablyValues, ui->spnQuadrant4->value());
        int c5 = proc[FIFTHCOL]->genPass(proc[FIFTHCOL]->column.probablyValues, ui->spnQuadrant5->value());
        int c6 = proc[SIXTHCOL]->genPass(proc[SIXTHCOL]->column.probablyValues, ui->spnQuadrant6->value());

        for(int i = FIRSTCOL; i < NUMCOLUMNS; i++)
        {
//            for(int k = 0; k < proc[i]->column.probablyValues.count(); k++)
//            {
//                qDebug() << "column" << i+1;
                if((c1 ==  columnsNumbers[i].at(f))||(c2 ==  columnsNumbers[i].at(f))||(c3 ==  columnsNumbers[i].at(f))
                        ||(c4 ==  columnsNumbers[i].at(f))||(c5 ==  columnsNumbers[i].at(f))||(c6 ==  columnsNumbers[i].at(f)))
                {
                    rules++;
//                    qDebug() << "oi" << proc[i]->column.probablyValues.at(k) <<  columnsNumbers[i].at(f) << "rules" << rules;
//                    break;
                }
//            }
            if(rules == 6)
            {
                if(i == 5)
                {
                    matchfound++;
                    gain << f+1;
                    qDebug() << " c1->" << c1 << " c2->" << c2 << " c3->" << c3 << " c4->" << c4 << " c5->" << c5 << " c6->" << c6;
                }
                rules = 0;
                break;
            }
        }
    }
    qDebug() << "resultado esperado-> " << matchfound << "  nos sorteios-> " << gain;
    //generate the next numbers compare with the real numbers
}
